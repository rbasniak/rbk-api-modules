using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using rbkApiModules.Commons.Core.Localization;
using System.IO.Compression;

namespace rbkApiModules.Commons.Core.CodeGeneration;

[Route("api/code-generator")]
[ApiController]
[IgnoreOnCodeGeneration]
[AllowAnonymous]
public class CodeGeneratorController : BaseController
{
    private readonly IWebHostEnvironment _environment;
    private readonly ILocalizationService _localization;

    public CodeGeneratorController(IWebHostEnvironment environment, ILocalizationService localization)
    {
        _localization = localization;
        _environment = environment;
    }

    [HttpGet]
    public async Task<ActionResult> Get(bool directUpdate, string projectId, CancellationToken cancellation)
    {
        String basePath;
        if (directUpdate)
        {
            var codePath = GetAutogeneratedFolder("frontend", projectId);
            Logger.Debug("Looking for repository in the following path: {path}", codePath);

            if (!Directory.Exists(codePath))
            {
                Logger.Debug("Path not found, trying another option");

                codePath = GetAutogeneratedFolder("front", projectId);

                Logger.Debug("Looking for repository in the following path: {path}", codePath);

                if (!Directory.Exists(codePath))
                {
                    return Ok($"Could not locate the auto-generated folder under '{codePath}'");
                }
            }
            else
            {
                Logger.Debug("Path found, using it!");
            }

            try
            {
                var files = Directory.GetFiles(codePath, "*.*", SearchOption.AllDirectories);

                if (files.Any(x => Path.GetExtension(x).ToLower() != ".ts"))
                {
                    Logger.Debug("Could not find any TypeScript file, aborting for security reasons");

                    return Ok("Aborting code generation because we might be in the wrong path: " + codePath.First());
                }

                foreach (var file in files)
                {
                    System.IO.File.Delete(file);
                }
            }
            catch (Exception ex)
            {
                Logger.Debug(ex, "Could not delete all files from repository");

                return Ok("Não foi possível apagar os arquivos no repositório");
            }

            basePath = codePath;
        }
        else
        {
            basePath = Path.Combine(_environment.ContentRootPath, "wwwroot", "_temp", Guid.NewGuid().ToString());

            Logger.Debug("Using the download option, files will be save in a temporary path: {path}", basePath);
        }

        if (directUpdate)
        {
            var codeGenerator = new AngularCodeGenerator(projectId, basePath, _localization);
            codeGenerator.Generate();

            return Ok("File successfully updated :)");
        }
        else
        {
            var codeGenerator = new AngularCodeGenerator(projectId, Path.Combine(basePath, "code"), _localization);
            codeGenerator.Generate();

            var zipFile = Path.Combine(basePath, "code.zip");
            ZipFile.CreateFromDirectory(Path.Combine(basePath, "code"), zipFile);

            var memory = new MemoryStream();
            using (var stream = new FileStream(zipFile, FileMode.Open))
            {
                await stream.CopyToAsync(memory);
            }
            memory.Position = 0;

            Directory.Delete(basePath, true);

            return File(memory, "application/zip", "code.zip");
        }
    }

    private string GetAutogeneratedFolder(string frontFolder, string projectId)
    {
        var searchString = Path.Combine(frontFolder, "src", "app", "auto-generated");

        if (!String.IsNullOrEmpty(projectId))
        {
            searchString = Path.Combine(frontFolder, projectId, "src", "app", "auto-generated");
        }

        var applicationPath = new DirectoryInfo(_environment.ContentRootPath);
        var codePath = Path.Combine(applicationPath.Parent.Parent.FullName, searchString);

        return codePath;
    }
}
